{"ast":null,"code":"import * as utils from './utils.js';\n/**\n * Returns whether passwordless authentication is available on this browser/platform or not.\n */\nexport function isAvailable() {\n  return !!window.PublicKeyCredential;\n}\n/**\n * Returns whether the device itself can be used as authenticator.\n */\nexport async function isLocalAuthenticator() {\n  return await PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();\n}\nasync function getAuthAttachment(authType) {\n  if (authType === \"local\") return \"platform\";\n  if (authType === \"roaming\" || authType === \"extern\") return \"cross-platform\";\n  if (authType === \"both\") return undefined; // The webauthn protocol considers `null` as invalid but `undefined` as \"both\"!\n  // the default case: \"auto\", depending on device capabilities\n  try {\n    if (await isLocalAuthenticator()) return \"platform\";else return \"cross-platform\";\n  } catch (e) {\n    // might happen due to some security policies\n    // see https://w3c.github.io/webauthn/#sctn-isUserVerifyingPlatformAuthenticatorAvailable\n    return undefined; // The webauthn protocol considers `null` as invalid but `undefined` as \"both\"!\n  }\n}\n\nfunction getAlgoName(num) {\n  switch (num) {\n    case -7:\n      return \"ES256\";\n    // case -8 ignored to to its rarity\n    case -257:\n      return \"RS256\";\n    default:\n      throw new Error(`Unknown algorithm code: ${num}`);\n  }\n}\n/**\n * Creates a cryptographic key pair, in order to register the public key for later passwordless authentication.\n *\n * @param {string} username\n * @param {string} challenge A server-side randomly generated string.\n * @param {Object} [options] Optional parameters.\n * @param {number} [options.timeout=60000] Number of milliseconds the user has to respond to the biometric/PIN check.\n * @param {'required'|'preferred'|'discouraged'} [options.userVerification='required'] Whether to prompt for biometric/PIN check or not.\n * @param {'auto'|'local'|'roaming'|'both'}       [options.authenticatorType='auto'] Which device to use as authenticator.\n *          'auto': if the local device can be used as authenticator it will be preferred. Otherwise it will prompt for a roaming device.\n *          'local': use the local device (using TouchID, FaceID, Windows Hello or PIN)\n *          'roaming': use a roaming device (security key or connected phone)\n *          'both': prompt the user to choose between local or roaming device. The UI and user interaction in this case is platform specific.\n * @param {boolean} [options.attestation=false] If enabled, the device attestation and clientData will be provided as Base64url encoded binary data.\n *                                Note that this is not available on some platforms.\n * @param {'discouraged'|'preferred'|'required'} [options.discoverable] If the credential is \"discoverable\", it can be selected using `authenticate` without providing credential IDs.\n *                                A native pop-up will appear for user selection. This may have an impact on \"passkeys\" user experience and syncing behavior.\n */\nexport async function register(username, challenge, options) {\n  options = options ?? {};\n  if (!utils.isBase64url(challenge)) throw new Error('Provided challenge is not properly encoded in Base64url');\n  const creationOptions = {\n    challenge: utils.parseBase64url(challenge),\n    rp: {\n      id: window.location.hostname,\n      name: window.location.hostname\n    },\n    user: {\n      id: options.userHandle ? utils.toBuffer(options.userHandle) : await utils.sha256(new TextEncoder().encode('passwordless.id-user:' + username)),\n      name: username,\n      displayName: username\n    },\n    pubKeyCredParams: [{\n      alg: -7,\n      type: \"public-key\"\n    }, {\n      alg: -257,\n      type: \"public-key\"\n    } // RS256 (for Windows Hello and others)\n    ],\n\n    timeout: options.timeout ?? 60000,\n    authenticatorSelection: {\n      userVerification: options.userVerification ?? \"required\",\n      authenticatorAttachment: await getAuthAttachment(options.authenticatorType ?? \"auto\"),\n      residentKey: options.discoverable ?? 'preferred',\n      requireResidentKey: options.discoverable === 'required' // mainly for backwards compatibility, see https://www.w3.org/TR/webauthn/#dictionary-authenticatorSelection\n    },\n\n    attestation: options.attestation ? \"direct\" : \"none\"\n  };\n  if (options.debug) console.debug(creationOptions);\n  const credential = await navigator.credentials.create({\n    publicKey: creationOptions\n  }); //PublicKeyCredential\n  if (options.debug) console.debug(credential);\n  const response = credential.response; // AuthenticatorAttestationResponse\n  let registration = {\n    username: username,\n    credential: {\n      id: credential.id,\n      publicKey: utils.toBase64url(response.getPublicKey()),\n      algorithm: getAlgoName(credential.response.getPublicKeyAlgorithm())\n    },\n    authenticatorData: utils.toBase64url(response.getAuthenticatorData()),\n    clientData: utils.toBase64url(response.clientDataJSON)\n  };\n  if (options.attestation) {\n    registration.attestationData = utils.toBase64url(response.attestationObject);\n  }\n  return registration;\n}\nasync function getTransports(authType) {\n  const local = ['internal'];\n  // 'hybrid' was added mid-2022 in the specs and currently not yet available in the official dom types\n  // @ts-ignore\n  const roaming = ['hybrid', 'usb', 'ble', 'nfc'];\n  if (authType === \"local\") return local;\n  if (authType == \"roaming\" || authType === \"extern\") return roaming;\n  if (authType === \"both\") return [...local, ...roaming];\n  // the default case: \"auto\", depending on device capabilities\n  try {\n    if (await isLocalAuthenticator()) return local;else return roaming;\n  } catch (e) {\n    return [...local, ...roaming];\n  }\n}\n/**\n * Signs a challenge using one of the provided credentials IDs in order to authenticate the user.\n *\n * @param {string[]} credentialIds The list of credential IDs that can be used for signing.\n * @param {string} challenge A server-side randomly generated string, the base64 encoded version will be signed.\n * @param {Object} [options] Optional parameters.\n * @param {number} [options.timeout=60000] Number of milliseconds the user has to respond to the biometric/PIN check.\n * @param {'required'|'preferred'|'discouraged'} [options.userVerification='required'] Whether to prompt for biometric/PIN check or not.\n * @param {'optional'|'conditional'|'required'|'silent'} [options.mediation='optional'] https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/get#mediation\n */\nexport async function authenticate(credentialIds, challenge, options) {\n  options = options ?? {};\n  if (!utils.isBase64url(challenge)) throw new Error('Provided challenge is not properly encoded in Base64url');\n  const transports = await getTransports(options.authenticatorType ?? \"auto\");\n  let authOptions = {\n    challenge: utils.parseBase64url(challenge),\n    rpId: window.location.hostname,\n    allowCredentials: credentialIds.map(id => {\n      return {\n        id: utils.parseBase64url(id),\n        type: 'public-key',\n        transports: transports\n      };\n    }),\n    userVerification: options.userVerification ?? \"required\",\n    timeout: options.timeout ?? 60000\n  };\n  if (options.debug) console.debug(authOptions);\n  let auth = await navigator.credentials.get({\n    publicKey: authOptions,\n    mediation: options.mediation\n  });\n  if (options.debug) console.debug(auth);\n  const response = auth.response;\n  const authentication = {\n    credentialId: auth.id,\n    //userHash: utils.toBase64url(response.userHandle), // unreliable, optional for authenticators\n    authenticatorData: utils.toBase64url(response.authenticatorData),\n    clientData: utils.toBase64url(response.clientDataJSON),\n    signature: utils.toBase64url(response.signature)\n  };\n  return authentication;\n}","map":{"version":3,"names":["utils","isAvailable","window","PublicKeyCredential","isLocalAuthenticator","isUserVerifyingPlatformAuthenticatorAvailable","getAuthAttachment","authType","undefined","e","getAlgoName","num","Error","register","username","challenge","options","isBase64url","creationOptions","parseBase64url","rp","id","location","hostname","name","user","userHandle","toBuffer","sha256","TextEncoder","encode","displayName","pubKeyCredParams","alg","type","timeout","authenticatorSelection","userVerification","authenticatorAttachment","authenticatorType","residentKey","discoverable","requireResidentKey","attestation","debug","console","credential","navigator","credentials","create","publicKey","response","registration","toBase64url","getPublicKey","algorithm","getPublicKeyAlgorithm","authenticatorData","getAuthenticatorData","clientData","clientDataJSON","attestationData","attestationObject","getTransports","local","roaming","authenticate","credentialIds","transports","authOptions","rpId","allowCredentials","map","auth","get","mediation","authentication","credentialId","signature"],"sources":["C:/Users/brandon.murphy/source/repos/FlightPWA/node_modules/@passwordless-id/webauthn/dist/esm/client.js"],"sourcesContent":["import * as utils from './utils.js';\n/**\n * Returns whether passwordless authentication is available on this browser/platform or not.\n */\nexport function isAvailable() {\n    return !!window.PublicKeyCredential;\n}\n/**\n * Returns whether the device itself can be used as authenticator.\n */\nexport async function isLocalAuthenticator() {\n    return await PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();\n}\nasync function getAuthAttachment(authType) {\n    if (authType === \"local\")\n        return \"platform\";\n    if (authType === \"roaming\" || authType === \"extern\")\n        return \"cross-platform\";\n    if (authType === \"both\")\n        return undefined; // The webauthn protocol considers `null` as invalid but `undefined` as \"both\"!\n    // the default case: \"auto\", depending on device capabilities\n    try {\n        if (await isLocalAuthenticator())\n            return \"platform\";\n        else\n            return \"cross-platform\";\n    }\n    catch (e) {\n        // might happen due to some security policies\n        // see https://w3c.github.io/webauthn/#sctn-isUserVerifyingPlatformAuthenticatorAvailable\n        return undefined; // The webauthn protocol considers `null` as invalid but `undefined` as \"both\"!\n    }\n}\nfunction getAlgoName(num) {\n    switch (num) {\n        case -7: return \"ES256\";\n        // case -8 ignored to to its rarity\n        case -257: return \"RS256\";\n        default: throw new Error(`Unknown algorithm code: ${num}`);\n    }\n}\n/**\n * Creates a cryptographic key pair, in order to register the public key for later passwordless authentication.\n *\n * @param {string} username\n * @param {string} challenge A server-side randomly generated string.\n * @param {Object} [options] Optional parameters.\n * @param {number} [options.timeout=60000] Number of milliseconds the user has to respond to the biometric/PIN check.\n * @param {'required'|'preferred'|'discouraged'} [options.userVerification='required'] Whether to prompt for biometric/PIN check or not.\n * @param {'auto'|'local'|'roaming'|'both'}       [options.authenticatorType='auto'] Which device to use as authenticator.\n *          'auto': if the local device can be used as authenticator it will be preferred. Otherwise it will prompt for a roaming device.\n *          'local': use the local device (using TouchID, FaceID, Windows Hello or PIN)\n *          'roaming': use a roaming device (security key or connected phone)\n *          'both': prompt the user to choose between local or roaming device. The UI and user interaction in this case is platform specific.\n * @param {boolean} [options.attestation=false] If enabled, the device attestation and clientData will be provided as Base64url encoded binary data.\n *                                Note that this is not available on some platforms.\n * @param {'discouraged'|'preferred'|'required'} [options.discoverable] If the credential is \"discoverable\", it can be selected using `authenticate` without providing credential IDs.\n *                                A native pop-up will appear for user selection. This may have an impact on \"passkeys\" user experience and syncing behavior.\n */\nexport async function register(username, challenge, options) {\n    options = options ?? {};\n    if (!utils.isBase64url(challenge))\n        throw new Error('Provided challenge is not properly encoded in Base64url');\n    const creationOptions = {\n        challenge: utils.parseBase64url(challenge),\n        rp: {\n            id: window.location.hostname,\n            name: window.location.hostname\n        },\n        user: {\n            id: options.userHandle ? utils.toBuffer(options.userHandle) : await utils.sha256(new TextEncoder().encode('passwordless.id-user:' + username)),\n            name: username,\n            displayName: username,\n        },\n        pubKeyCredParams: [\n            { alg: -7, type: \"public-key\" },\n            { alg: -257, type: \"public-key\" }, // RS256 (for Windows Hello and others)\n        ],\n        timeout: options.timeout ?? 60000,\n        authenticatorSelection: {\n            userVerification: options.userVerification ?? \"required\",\n            authenticatorAttachment: await getAuthAttachment(options.authenticatorType ?? \"auto\"),\n            residentKey: options.discoverable ?? 'preferred',\n            requireResidentKey: (options.discoverable === 'required') // mainly for backwards compatibility, see https://www.w3.org/TR/webauthn/#dictionary-authenticatorSelection\n        },\n        attestation: options.attestation ? \"direct\" : \"none\"\n    };\n    if (options.debug)\n        console.debug(creationOptions);\n    const credential = await navigator.credentials.create({ publicKey: creationOptions }); //PublicKeyCredential\n    if (options.debug)\n        console.debug(credential);\n    const response = credential.response; // AuthenticatorAttestationResponse\n    let registration = {\n        username: username,\n        credential: {\n            id: credential.id,\n            publicKey: utils.toBase64url(response.getPublicKey()),\n            algorithm: getAlgoName(credential.response.getPublicKeyAlgorithm())\n        },\n        authenticatorData: utils.toBase64url(response.getAuthenticatorData()),\n        clientData: utils.toBase64url(response.clientDataJSON),\n    };\n    if (options.attestation) {\n        registration.attestationData = utils.toBase64url(response.attestationObject);\n    }\n    return registration;\n}\nasync function getTransports(authType) {\n    const local = ['internal'];\n    // 'hybrid' was added mid-2022 in the specs and currently not yet available in the official dom types\n    // @ts-ignore\n    const roaming = ['hybrid', 'usb', 'ble', 'nfc'];\n    if (authType === \"local\")\n        return local;\n    if (authType == \"roaming\" || authType === \"extern\")\n        return roaming;\n    if (authType === \"both\")\n        return [...local, ...roaming];\n    // the default case: \"auto\", depending on device capabilities\n    try {\n        if (await isLocalAuthenticator())\n            return local;\n        else\n            return roaming;\n    }\n    catch (e) {\n        return [...local, ...roaming];\n    }\n}\n/**\n * Signs a challenge using one of the provided credentials IDs in order to authenticate the user.\n *\n * @param {string[]} credentialIds The list of credential IDs that can be used for signing.\n * @param {string} challenge A server-side randomly generated string, the base64 encoded version will be signed.\n * @param {Object} [options] Optional parameters.\n * @param {number} [options.timeout=60000] Number of milliseconds the user has to respond to the biometric/PIN check.\n * @param {'required'|'preferred'|'discouraged'} [options.userVerification='required'] Whether to prompt for biometric/PIN check or not.\n * @param {'optional'|'conditional'|'required'|'silent'} [options.mediation='optional'] https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/get#mediation\n */\nexport async function authenticate(credentialIds, challenge, options) {\n    options = options ?? {};\n    if (!utils.isBase64url(challenge))\n        throw new Error('Provided challenge is not properly encoded in Base64url');\n    const transports = await getTransports(options.authenticatorType ?? \"auto\");\n    let authOptions = {\n        challenge: utils.parseBase64url(challenge),\n        rpId: window.location.hostname,\n        allowCredentials: credentialIds.map(id => {\n            return {\n                id: utils.parseBase64url(id),\n                type: 'public-key',\n                transports: transports,\n            };\n        }),\n        userVerification: options.userVerification ?? \"required\",\n        timeout: options.timeout ?? 60000,\n    };\n    if (options.debug)\n        console.debug(authOptions);\n    let auth = await navigator.credentials.get({ publicKey: authOptions, mediation: options.mediation });\n    if (options.debug)\n        console.debug(auth);\n    const response = auth.response;\n    const authentication = {\n        credentialId: auth.id,\n        //userHash: utils.toBase64url(response.userHandle), // unreliable, optional for authenticators\n        authenticatorData: utils.toBase64url(response.authenticatorData),\n        clientData: utils.toBase64url(response.clientDataJSON),\n        signature: utils.toBase64url(response.signature),\n    };\n    return authentication;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}