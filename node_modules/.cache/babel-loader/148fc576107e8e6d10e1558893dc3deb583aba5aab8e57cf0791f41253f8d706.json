{"ast":null,"code":"import { parseAuthentication, parseRegistration } from \"./parsers.js\";\nimport * as utils from './utils.js';\nasync function isValid(validator, value) {\n  if (typeof validator === 'function') {\n    const res = validator(value);\n    if (res instanceof Promise) return await res;else return res;\n  }\n  // the validator can be a single value too\n  return validator === value;\n}\nasync function isNotValid(validator, value) {\n  return !(await isValid(validator, value));\n}\nexport async function verifyRegistration(registrationRaw, expected) {\n  const registration = parseRegistration(registrationRaw);\n  registration.client.challenge;\n  if (registration.client.type !== \"webauthn.create\") throw new Error(`Unexpected ClientData type: ${registration.client.type}`);\n  if (await isNotValid(expected.origin, registration.client.origin)) throw new Error(`Unexpected ClientData origin: ${registration.client.origin}`);\n  if (await isNotValid(expected.challenge, registration.client.challenge)) throw new Error(`Unexpected ClientData challenge: ${registration.client.challenge}`);\n  return registration;\n}\nexport async function verifyAuthentication(authenticationRaw, credential, expected) {\n  if (authenticationRaw.credentialId !== credential.id) throw new Error(`Credential ID mismatch: ${authenticationRaw.credentialId} vs ${credential.id}`);\n  const isValidSignature = await verifySignature({\n    algorithm: credential.algorithm,\n    publicKey: credential.publicKey,\n    authenticatorData: authenticationRaw.authenticatorData,\n    clientData: authenticationRaw.clientData,\n    signature: authenticationRaw.signature\n  });\n  if (!isValidSignature) throw new Error(`Invalid signature: ${authenticationRaw.signature}`);\n  const authentication = parseAuthentication(authenticationRaw);\n  if (authentication.client.type !== \"webauthn.get\") throw new Error(`Unexpected clientData type: ${authentication.client.type}`);\n  if (await isNotValid(expected.origin, authentication.client.origin)) throw new Error(`Unexpected ClientData origin: ${authentication.client.origin}`);\n  if (await isNotValid(expected.challenge, authentication.client.challenge)) throw new Error(`Unexpected ClientData challenge: ${authentication.client.challenge}`);\n  // this only works because we consider `rp.origin` and `rp.id` to be the same during authentication/registration\n  const rpId = new URL(authentication.client.origin).hostname;\n  const expectedRpIdHash = utils.toBase64url(await utils.sha256(utils.toBuffer(rpId)));\n  if (authentication.authenticator.rpIdHash !== expectedRpIdHash) throw new Error(`Unexpected RpIdHash: ${authentication.authenticator.rpIdHash} vs ${expectedRpIdHash}`);\n  if (!authentication.authenticator.flags.userPresent) throw new Error(`Unexpected authenticator flags: missing userPresent`);\n  if (!authentication.authenticator.flags.userVerified && expected.userVerified) throw new Error(`Unexpected authenticator flags: missing userVerified`);\n  if (authentication.authenticator.counter <= expected.counter) throw new Error(`Unexpected authenticator counter: ${authentication.authenticator.counter} (should be > ${expected.counter})`);\n  return authentication;\n}\n// https://w3c.github.io/webauthn/#sctn-public-key-easy\n// https://www.iana.org/assignments/cose/cose.xhtml#algorithms\n/*\nUser agents MUST be able to return a non-null value for getPublicKey() when the credential public key has a COSEAlgorithmIdentifier value of:\n\n-7 (ES256), where kty is 2 (with uncompressed points) and crv is 1 (P-256).\n\n-257 (RS256).\n\n-8 (EdDSA), where crv is 6 (Ed25519).\n*/\nfunction getAlgoParams(algorithm) {\n  switch (algorithm) {\n    case 'RS256':\n      return {\n        name: 'RSASSA-PKCS1-v1_5',\n        hash: 'SHA-256'\n      };\n    case 'ES256':\n      return {\n        name: 'ECDSA',\n        namedCurve: 'P-256',\n        hash: 'SHA-256'\n      };\n    // case 'EdDSA': Not supported by browsers\n    default:\n      throw new Error(`Unknown or unsupported crypto algorithm: ${algorithm}. Only 'RS256' and 'ES256' are supported.`);\n  }\n}\nasync function parseCryptoKey(algoParams, publicKey) {\n  const buffer = utils.parseBase64url(publicKey);\n  return crypto.subtle.importKey('spki', buffer, algoParams, false, ['verify']);\n}\n// https://w3c.github.io/webauthn/#sctn-verifying-assertion\n// https://w3c.github.io/webauthn/#sctn-signature-attestation-types\n/* Emphasis mine:\n\n6.5.6. Signature Formats for Packed Attestation, FIDO U2F Attestation, and **Assertion Signatures**\n\n[...] For COSEAlgorithmIdentifier -7 (ES256) [...] the sig value MUST be encoded as an ASN.1 [...]\n[...] For COSEAlgorithmIdentifier -257 (RS256) [...] The signature is not ASN.1 wrapped.\n[...] For COSEAlgorithmIdentifier -37 (PS256) [...] The signature is not ASN.1 wrapped.\n*/\n// see also https://gist.github.com/philholden/50120652bfe0498958fd5926694ba354\nexport async function verifySignature({\n  algorithm,\n  publicKey,\n  authenticatorData,\n  clientData,\n  signature\n}) {\n  const algoParams = getAlgoParams(algorithm);\n  let cryptoKey = await parseCryptoKey(algoParams, publicKey);\n  console.debug(cryptoKey);\n  let clientHash = await utils.sha256(utils.parseBase64url(clientData));\n  // during \"login\", the authenticatorData is exactly 37 bytes\n  let comboBuffer = utils.concatenateBuffers(utils.parseBase64url(authenticatorData), clientHash);\n  console.debug('Crypto Algo: ' + JSON.stringify(algoParams));\n  console.debug('Public key: ' + publicKey);\n  console.debug('Data: ' + utils.toBase64url(comboBuffer));\n  console.debug('Signature: ' + signature);\n  // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/verify\n  let signatureBuffer = utils.parseBase64url(signature);\n  if (algorithm == 'ES256') signatureBuffer = convertASN1toRaw(signatureBuffer);\n  const isValid = await crypto.subtle.verify(algoParams, cryptoKey, signatureBuffer, comboBuffer);\n  return isValid;\n}\nfunction convertASN1toRaw(signatureBuffer) {\n  // Convert signature from ASN.1 sequence to \"raw\" format\n  const usignature = new Uint8Array(signatureBuffer);\n  const rStart = usignature[4] === 0 ? 5 : 4;\n  const rEnd = rStart + 32;\n  const sStart = usignature[rEnd + 2] === 0 ? rEnd + 3 : rEnd + 2;\n  const r = usignature.slice(rStart, rEnd);\n  const s = usignature.slice(sStart);\n  return new Uint8Array([...r, ...s]);\n}","map":{"version":3,"names":["parseAuthentication","parseRegistration","utils","isValid","validator","value","res","Promise","isNotValid","verifyRegistration","registrationRaw","expected","registration","client","challenge","type","Error","origin","verifyAuthentication","authenticationRaw","credential","credentialId","id","isValidSignature","verifySignature","algorithm","publicKey","authenticatorData","clientData","signature","authentication","rpId","URL","hostname","expectedRpIdHash","toBase64url","sha256","toBuffer","authenticator","rpIdHash","flags","userPresent","userVerified","counter","getAlgoParams","name","hash","namedCurve","parseCryptoKey","algoParams","buffer","parseBase64url","crypto","subtle","importKey","cryptoKey","console","debug","clientHash","comboBuffer","concatenateBuffers","JSON","stringify","signatureBuffer","convertASN1toRaw","verify","usignature","Uint8Array","rStart","rEnd","sStart","r","slice","s"],"sources":["C:/Users/brandon.murphy/source/repos/FlightPWA/node_modules/@passwordless-id/webauthn/dist/esm/server.js"],"sourcesContent":["import { parseAuthentication, parseRegistration } from \"./parsers.js\";\nimport * as utils from './utils.js';\nasync function isValid(validator, value) {\n    if (typeof validator === 'function') {\n        const res = validator(value);\n        if (res instanceof Promise)\n            return await res;\n        else\n            return res;\n    }\n    // the validator can be a single value too\n    return validator === value;\n}\nasync function isNotValid(validator, value) {\n    return !(await isValid(validator, value));\n}\nexport async function verifyRegistration(registrationRaw, expected) {\n    const registration = parseRegistration(registrationRaw);\n    registration.client.challenge;\n    if (registration.client.type !== \"webauthn.create\")\n        throw new Error(`Unexpected ClientData type: ${registration.client.type}`);\n    if (await isNotValid(expected.origin, registration.client.origin))\n        throw new Error(`Unexpected ClientData origin: ${registration.client.origin}`);\n    if (await isNotValid(expected.challenge, registration.client.challenge))\n        throw new Error(`Unexpected ClientData challenge: ${registration.client.challenge}`);\n    return registration;\n}\nexport async function verifyAuthentication(authenticationRaw, credential, expected) {\n    if (authenticationRaw.credentialId !== credential.id)\n        throw new Error(`Credential ID mismatch: ${authenticationRaw.credentialId} vs ${credential.id}`);\n    const isValidSignature = await verifySignature({\n        algorithm: credential.algorithm,\n        publicKey: credential.publicKey,\n        authenticatorData: authenticationRaw.authenticatorData,\n        clientData: authenticationRaw.clientData,\n        signature: authenticationRaw.signature\n    });\n    if (!isValidSignature)\n        throw new Error(`Invalid signature: ${authenticationRaw.signature}`);\n    const authentication = parseAuthentication(authenticationRaw);\n    if (authentication.client.type !== \"webauthn.get\")\n        throw new Error(`Unexpected clientData type: ${authentication.client.type}`);\n    if (await isNotValid(expected.origin, authentication.client.origin))\n        throw new Error(`Unexpected ClientData origin: ${authentication.client.origin}`);\n    if (await isNotValid(expected.challenge, authentication.client.challenge))\n        throw new Error(`Unexpected ClientData challenge: ${authentication.client.challenge}`);\n    // this only works because we consider `rp.origin` and `rp.id` to be the same during authentication/registration\n    const rpId = new URL(authentication.client.origin).hostname;\n    const expectedRpIdHash = utils.toBase64url(await utils.sha256(utils.toBuffer(rpId)));\n    if (authentication.authenticator.rpIdHash !== expectedRpIdHash)\n        throw new Error(`Unexpected RpIdHash: ${authentication.authenticator.rpIdHash} vs ${expectedRpIdHash}`);\n    if (!authentication.authenticator.flags.userPresent)\n        throw new Error(`Unexpected authenticator flags: missing userPresent`);\n    if (!authentication.authenticator.flags.userVerified && expected.userVerified)\n        throw new Error(`Unexpected authenticator flags: missing userVerified`);\n    if (authentication.authenticator.counter <= expected.counter)\n        throw new Error(`Unexpected authenticator counter: ${authentication.authenticator.counter} (should be > ${expected.counter})`);\n    return authentication;\n}\n// https://w3c.github.io/webauthn/#sctn-public-key-easy\n// https://www.iana.org/assignments/cose/cose.xhtml#algorithms\n/*\nUser agents MUST be able to return a non-null value for getPublicKey() when the credential public key has a COSEAlgorithmIdentifier value of:\n\n-7 (ES256), where kty is 2 (with uncompressed points) and crv is 1 (P-256).\n\n-257 (RS256).\n\n-8 (EdDSA), where crv is 6 (Ed25519).\n*/\nfunction getAlgoParams(algorithm) {\n    switch (algorithm) {\n        case 'RS256':\n            return {\n                name: 'RSASSA-PKCS1-v1_5',\n                hash: 'SHA-256'\n            };\n        case 'ES256':\n            return {\n                name: 'ECDSA',\n                namedCurve: 'P-256',\n                hash: 'SHA-256',\n            };\n        // case 'EdDSA': Not supported by browsers\n        default:\n            throw new Error(`Unknown or unsupported crypto algorithm: ${algorithm}. Only 'RS256' and 'ES256' are supported.`);\n    }\n}\nasync function parseCryptoKey(algoParams, publicKey) {\n    const buffer = utils.parseBase64url(publicKey);\n    return crypto.subtle.importKey('spki', buffer, algoParams, false, ['verify']);\n}\n// https://w3c.github.io/webauthn/#sctn-verifying-assertion\n// https://w3c.github.io/webauthn/#sctn-signature-attestation-types\n/* Emphasis mine:\n\n6.5.6. Signature Formats for Packed Attestation, FIDO U2F Attestation, and **Assertion Signatures**\n\n[...] For COSEAlgorithmIdentifier -7 (ES256) [...] the sig value MUST be encoded as an ASN.1 [...]\n[...] For COSEAlgorithmIdentifier -257 (RS256) [...] The signature is not ASN.1 wrapped.\n[...] For COSEAlgorithmIdentifier -37 (PS256) [...] The signature is not ASN.1 wrapped.\n*/\n// see also https://gist.github.com/philholden/50120652bfe0498958fd5926694ba354\nexport async function verifySignature({ algorithm, publicKey, authenticatorData, clientData, signature }) {\n    const algoParams = getAlgoParams(algorithm);\n    let cryptoKey = await parseCryptoKey(algoParams, publicKey);\n    console.debug(cryptoKey);\n    let clientHash = await utils.sha256(utils.parseBase64url(clientData));\n    // during \"login\", the authenticatorData is exactly 37 bytes\n    let comboBuffer = utils.concatenateBuffers(utils.parseBase64url(authenticatorData), clientHash);\n    console.debug('Crypto Algo: ' + JSON.stringify(algoParams));\n    console.debug('Public key: ' + publicKey);\n    console.debug('Data: ' + utils.toBase64url(comboBuffer));\n    console.debug('Signature: ' + signature);\n    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/verify\n    let signatureBuffer = utils.parseBase64url(signature);\n    if (algorithm == 'ES256')\n        signatureBuffer = convertASN1toRaw(signatureBuffer);\n    const isValid = await crypto.subtle.verify(algoParams, cryptoKey, signatureBuffer, comboBuffer);\n    return isValid;\n}\nfunction convertASN1toRaw(signatureBuffer) {\n    // Convert signature from ASN.1 sequence to \"raw\" format\n    const usignature = new Uint8Array(signatureBuffer);\n    const rStart = usignature[4] === 0 ? 5 : 4;\n    const rEnd = rStart + 32;\n    const sStart = usignature[rEnd + 2] === 0 ? rEnd + 3 : rEnd + 2;\n    const r = usignature.slice(rStart, rEnd);\n    const s = usignature.slice(sStart);\n    return new Uint8Array([...r, ...s]);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}